{
  "parents": [
    {
      "sha": "1335859f428f4c0d780b88b0873819048c2c04e2",
      "url": "https://api.github.com/repos/theplant/GBox/commits/1335859f428f4c0d780b88b0873819048c2c04e2"
    }
  ],
  "sha": "b13f907d49bf5b14f7182446ecebea9ac5b58c33",
  "commit": {
    "message": "No need for refresh of server info in core data, improvment of performance and stability, gdoc is very slow today, so this is not tested thorougly.",
    "tree": {
      "sha": "10797f732367c919e039621e76bf8a51f2175c45",
      "url": "https://api.github.com/repos/theplant/GBox/git/trees/10797f732367c919e039621e76bf8a51f2175c45"
    },
    "author": {
      "email": "xiaoyi.chen@hotmail.com",
      "date": "2011-08-29T01:39:56-07:00",
      "name": "Xiaoyi Chen"
    },
    "committer": {
      "email": "xiaoyi.chen@hotmail.com",
      "date": "2011-08-29T01:39:56-07:00",
      "name": "Xiaoyi Chen"
    },
    "url": "https://api.github.com/repos/theplant/GBox/git/commits/b13f907d49bf5b14f7182446ecebea9ac5b58c33"
  },
  "author": {
    "avatar_url": "https://secure.gravatar.com/avatar/38eb4e6b823b7e406e11de34be7fe61d?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-140.png",
    "login": "chenxiaoyi",
    "id": 877966,
    "url": "https://api.github.com/users/chenxiaoyi"
  },
  "files": [
    {
      "raw_url": "https://github.com/theplant/GBox/raw/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBCollectionManager.m",
      "changes": 3,
      "status": "modified",
      "sha": "b13f907d49bf5b14f7182446ecebea9ac5b58c33",
      "additions": 1,
      "filename": "GBox/GBCollectionManager.m",
      "deletions": 2,
      "patch": "--- a/GBox/GBCollectionManager.m\n+++ b/GBox/GBCollectionManager.m\n@@ -128,9 +128,8 @@\n     */\n     NSArray *parentFolderEntries = [folderHrefDic objectsForKeys:parentHrefs notFoundMarker:notFoundMarkerEntry];\n     return parentFolderEntries;\n-    \n-}\n \n+}\n \n static GBCollectionManager* sharedInstance = nil;\n + (GBCollectionManager *)sharedCollectionManager {",
      "blob_url": "https://github.com/theplant/GBox/blob/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBCollectionManager.m"
    },
    {
      "raw_url": "https://github.com/theplant/GBox/raw/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBDataFacility.m",
      "changes": 3,
      "status": "modified",
      "sha": "b13f907d49bf5b14f7182446ecebea9ac5b58c33",
      "additions": 1,
      "filename": "GBox/GBDataFacility.m",
      "deletions": 2,
      "patch": "--- a/GBox/GBDataFacility.m\n+++ b/GBox/GBDataFacility.m\n@@ -324,11 +324,10 @@ static GBDataFacility* instance =nil;\n               ([error localizedDescription] != nil) ? [error localizedDescription] : @\"Unknown Error\");\n         exit(1);\n     }\n-    \n \n }\n \n--(void)clearData{\n+-(void)clearData{ \n     //Refresh Data\n     [GBUtility removePersistentStore:DB_storeURL];\n ",
      "blob_url": "https://github.com/theplant/GBox/blob/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBDataFacility.m"
    },
    {
      "raw_url": "https://github.com/theplant/GBox/raw/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBSyncController.m",
      "changes": 146,
      "status": "modified",
      "sha": "b13f907d49bf5b14f7182446ecebea9ac5b58c33",
      "additions": 15,
      "filename": "GBox/GBSyncController.m",
      "deletions": 131,
      "patch": "--- a/GBox/GBSyncController.m\n+++ b/GBox/GBSyncController.m\n@@ -108,70 +108,27 @@ static GBSyncController * shareSyncController = nil;\n     }\n     return shareSyncController;\n }\n-\n--(BOOL)initData{\n-    //Core Data Basic Test\n-    //[dataFacility refresh];\n-    \n-    for(GDataEntryFolderDoc * entry in [[docListData docListFeed] entriesWithCategoryKind:kGDataCategoryFolderDoc]){\n-        //NSLog(@\"The designated file is found:%@\",[dataFacility fetchDocEntryByIdentifier:[entry identifier]] );\n-        \n-        [dataFacility insertCollection:entry];\n-    }\n-    \n-\n-    [dataFacility handleRelationshipBetweenCollections];\n-    \n+-(void)initialServerEntryCheck{\n     for(GDataEntryDocBase* entry in [[docListData docListFeed ]entries]){\n         if([entry class]!= [GDataEntryFolderDoc class]){\n-            [dataFacility insertDocEntry:entry];\n-        }\n-    }\n-    \n-    [dataFacility handleLevelAndPathForCollection];\n-    \n-    [dataFacility handlePathForEntry];\n-    \n-    [dataFacility contextSave];\n-\n-    //NSArray *collectionsInData = [dataFacility FetchAllEntriesOf:@\"GBCollectionEntity\"];\n-    //NSArray *docEntriesInData = [dataFacility FetchAllEntriesOf:@\"GBDocEntryEntity\"];\n-\n-    //[dataFacility DisplayDocEntries:docEntriesInData];\n-    \n-    //[dataFacility refresh];\n-    \n-    //[dataFacility checkServerCollectionsForPossibleTask:collectionsInData];\n-    //[dataFacility checkServerEntriesForPossibleTask:docEntriesInData];\n-    \n-    return YES;\n-    \n-}\n-\n--(void)initialServerEntryCheck:(NSArray*)docEntries{\n-    \n-    for(NSManagedObject* mo in docEntries){\n+        \n         [dataFacility insertEvent:0\n                     withEventCode:kGBServerNewFile\n-                         operandA:[mo valueForKey:@\"identifier\"]\n+                         operandA:[entry identifier]\n                       andOperandB:nil];\n-                \n+        }      \n     }\n     \n }\n \n--(void)initialServerCollectionsCheck:(NSArray*)collections{\n-    \n-    for(NSManagedObject* mo in collections){\n-        NSArray* pathEntries = [mo valueForKey:@\"localPaths\"];\n-        for(NSManagedObject* pathMO in pathEntries){\n+-(void)initialServerCollectionsCheck{\n+    for(GDataEntryFolderDoc * entry in [[docListData docListFeed] entriesWithCategoryKind:kGDataCategoryFolderDoc]){\n             //The local directory is not exist\n             //[GBUtility createLocalFolderAtPath:[pathMO valueForKey:@\"stringValue\"]];\n             [dataFacility insertEvent:0\n                         withEventCode:kGBServerNewCollection\n-                             operandA:[mo valueForKey:@\"identifier\"]\n+                             operandA:[entry identifier]\n                           andOperandB:nil];\n-        }        \n     }\n }\n \n@@ -191,6 +148,7 @@ static GBSyncController * shareSyncController = nil;\n -(void)handleTasks:(NSTimer*)timer{\n     NSUInteger countOfWaitingTasks= [dataFacility countOfWaitingTasks];\n     NSUInteger countOfExecutingTasks = [dataFacility countOfExecutingTasks];\n+    \n     /*\n     if(countOfExecutingTasks!=0){\n         NSArray* executingTasks = [dataFacility fetchTaskOfState:kGBStateExecuting];\n@@ -205,15 +163,17 @@ static GBSyncController * shareSyncController = nil;\n             }\n         }\n     }\n-     */\n+    */\n     \n     if(countOfWaitingTasks!=0&&countOfExecutingTasks==0){\n         [statusItem setImage:[NSImage imageNamed:@\"statusicon2\"]];\n         [docListData fetchDocList];\n         synced= NO;\n+        [dataFacility contextSave];\n     }else if(synced==NO && countOfExecutingTasks==0){\n         [statusItem setImage:[NSImage imageNamed:@\"statusicon\"]];\n         synced=YES;\n+        [dataFacility contextSave];\n     }\n     \n     \n@@ -227,68 +187,6 @@ static GBSyncController * shareSyncController = nil;\n     setupFinished = yesOrNo;\n }\n \n--(void)backupTaskData{\n-    NSArray* waitingTaskArray = [dataFacility fetchTaskOfState:kGBStateWaiting];\n-    NSArray* executingTaskArray = [dataFacility fetchTaskOfState:kGBStateExecuting];\n-    NSArray* finishedTaskArray = [dataFacility fetchTaskOfState:kGBStateDone];\n-    \n-    waitingTasksCache = [[NSMutableArray alloc]init ];\n-    for(NSManagedObject *mo in waitingTaskArray){\n-        [waitingTasksCache addObject:[NSDictionary dictionaryWithObjectsAndKeys:\n-                                      [mo valueForKey:@\"eventID\"],@\"eventID\",\n-                                      [mo valueForKey:@\"eventCode\"],@\"eventCode\",\n-                                      [mo valueForKey:@\"operandA\"],@\"operandA\",\n-                                      [mo valueForKey:@\"operandB\"],@\"operandB\",\n-                                      nil] ];\n-    }\n-    executingTasksCache = [[NSMutableArray alloc]init];\n-    for(NSManagedObject *mo in executingTaskArray){\n-        [executingTasksCache addObject:[NSDictionary dictionaryWithObjectsAndKeys:\n-                                        [mo valueForKey:@\"eventID\"],@\"eventID\",\n-                                        [mo valueForKey:@\"eventCode\"],@\"eventCode\",\n-                                        [mo valueForKey:@\"operandA\"],@\"operandA\",\n-                                        [mo valueForKey:@\"operandB\"],@\"operandB\",\n-                                        nil] ];\n-    }\n-    \n-    finishedTasksCache = [[NSMutableArray alloc]init];\n-    for(NSManagedObject *mo in finishedTaskArray){\n-        [finishedTasksCache addObject:[NSDictionary dictionaryWithObjectsAndKeys:\n-                                       [mo valueForKey:@\"eventID\"],@\"eventID\",\n-                                       [mo valueForKey:@\"eventCode\"],@\"eventCode\",\n-                                       [mo valueForKey:@\"operandA\"],@\"operandA\",\n-                                       [mo valueForKey:@\"operandB\"],@\"operandB\",\n-                                       nil] ];\n-    }\n-\n-}\n-\n--(void)resumeTaskData{\n-    \n-    for(NSDictionary *dic in waitingTasksCache){\n-        [dataFacility insertEvent:[dic valueForKey:@\"eventID\"] \n-                    withEventCode:[[dic valueForKey:@\"eventCode\"] integerValue]\n-                         operandA:[dic valueForKey:@\"operandA\"] \n-                         operandB:[dic valueForKey:@\"operandB\"]\n-               andStateWithouSave:kGBStateWaiting];\n-    }\n-    for(NSDictionary *dic in executingTasksCache){\n-        [dataFacility insertEvent:[dic valueForKey:@\"eventID\"]\n-                    withEventCode:[[dic valueForKey:@\"eventCode\"] integerValue]\n-                         operandA:[dic valueForKey:@\"operandA\"] \n-                         operandB:[dic valueForKey:@\"operandB\"]\n-               andStateWithouSave:kGBStateExecuting];\n-    }\n-    \n-    for(NSDictionary *dic in finishedTasksCache){\n-        [dataFacility insertEvent:[dic valueForKey:@\"eventID\"]\n-                    withEventCode:[[dic valueForKey:@\"eventCode\"] integerValue]\n-                         operandA:[dic valueForKey:@\"operandA\"] \n-                         operandB:[dic valueForKey:@\"operandB\"]\n-               andStateWithouSave:kGBStateDone];\n-    }\n-}\n-\n -(void)setInitialDocListFetchSucceed:(BOOL)yesORno{\n     firstDocListFetchSucceed = yesORno;\n }\n@@ -299,30 +197,16 @@ static GBSyncController * shareSyncController = nil;\n     \n     if (setupFinished) {\n         if(firstDocListFetchSucceed){\n-            //[collectionManager setFolderHrefDic];\n             [collectionManager setFolderHrefDic];\n-            [self backupTaskData];\n-            [dataFacility clearData];\n-            [self resumeTaskData];\n-            [dataFacility setCollectionManager:collectionManager];\n-            \n-            if([self initData]){\n-                \n-                [taskHandler handleTasks];\n-            }\n-\n+            [taskHandler handleTasks];\n         }else{\n             firstDocListFetchSucceed = YES;\n             [self beginSync];\n         }\n     }else{\n         [collectionManager setFolderHrefDic];\n-        if([self initData]){\n-            NSArray *collectionsInData = [dataFacility FetchAllEntriesOf:@\"GBCollectionEntity\"];\n-            NSArray *docEntriesInData = [dataFacility FetchAllEntriesOf:@\"GBDocEntryEntity\"];\n-            [self initialServerCollectionsCheck:collectionsInData];\n-            [self initialServerEntryCheck:docEntriesInData];\n-        }\n+        [self initialServerCollectionsCheck];\n+        [self initialServerEntryCheck];\n         [self beginSync];\n         setupFinished = YES ;\n \n@@ -436,7 +320,7 @@ static GBSyncController * shareSyncController = nil;\n                 }//Ensure This entry is processed only once.   \n                 \n             }//For each entry doc/collection\n-            \n+            [dataFacility contextSave];\n         }//Any changes new\n         \n     }//changeEntries nil",
      "blob_url": "https://github.com/theplant/GBox/blob/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBSyncController.m"
    },
    {
      "raw_url": "https://github.com/theplant/GBox/raw/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBTaskHandler.m",
      "changes": 287,
      "status": "modified",
      "sha": "b13f907d49bf5b14f7182446ecebea9ac5b58c33",
      "additions": 86,
      "filename": "GBox/GBTaskHandler.m",
      "deletions": 201,
      "patch": "--- a/GBox/GBTaskHandler.m\n+++ b/GBox/GBTaskHandler.m\n@@ -81,37 +81,38 @@\n -(void)handleServerFileUpdated:(NSManagedObject*)taskMO{\n     NSManagedObjectID *taskID = [taskMO objectID];\n     [dataFacility setState:kGBStateExecuting ofTaskID:taskID];\n-    NSInteger eventCode = [[taskMO valueForKey:@\"eventCode\"] intValue];\n-    NSString *operandA = [taskMO valueForKey:@\"operandA\"];\n-    NSString *operandB = [taskMO valueForKey:@\"operandB\"];\n-    NSString* identifier = operandA;\n-    GDataEntryDocBase* entry = [docListData entryForIdentifier:operandA];\n+    NSString* identifier = [taskMO valueForKey:@\"operandA\"];\n+    GDataEntryDocBase* entry = [docListData entryForIdentifier:identifier];\n     BOOL isCollection = ([entry class]==[GDataEntryFolderDoc class])?YES:NO;\n     NSString* entryTitle = [[entry title] stringValue];\n     \n     NSSet* pathSet = [localIdentifierDic valueForKey:identifier];\n+    \n     if(pathSet!=nil && [pathSet count]!=0){\n         //File exist at local.\n-        \n-        //If not updated, check rename by filename & suggested filename\n-        NSString* fileName = [entry filename];\n-        NSString* suggestedFilename = [entry suggestedFilename];\n-        if(![fileName isEqualToString: suggestedFilename]){\n-            //The file is renamed.\n-            NSString* identifier = operandA;\n-            NSSet* pathSet = [localIdentifierDic valueForKey:identifier];\n-            NSString* suggestedName = [[docListData docListFeed]entryForIdentifier:identifier];\n-            NSError * error = nil;\n-            for(NSString* path in pathSet){\n-                NSString * newPath =[NSString stringWithFormat:@\"%@/%@\", [path stringByDeletingLastPathComponent],suggestedName];\n-                [[NSFileManager defaultManager] moveItemAtPath:[GBUtility expandedPath: path]\n-                                                        toPath:[GBUtility expandedPath: newPath]\n-                                                         error:&error];\n+        if(isCollection){\n+            [self handleServerNewCollection:taskMO];\n+        }else{\n+            //If not updated, check rename by filename & suggested filename\n+            NSString* fileName = [entry filename];\n+            NSString* suggestedFilename = [entry suggestedFilename];\n+            if(![fileName isEqualToString: suggestedFilename]){\n+                //The file is renamed.\n+                NSSet* pathSet = [localIdentifierDic valueForKey:identifier];\n+                NSString* suggestedName = [[docListData docListFeed]entryForIdentifier:identifier];\n+                NSError * error = nil;\n+                for(NSString* path in pathSet){\n+                    NSString * newPath =[NSString stringWithFormat:@\"%@/%@\", [path stringByDeletingLastPathComponent],suggestedName];\n+                    [[NSFileManager defaultManager] moveItemAtPath:[GBUtility expandedPath: path]\n+                                                            toPath:[GBUtility expandedPath: newPath]\n+                                                             error:&error];\n+                }\n+                \n             }\n-            \n-            [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n-            [currentExecutingTasks removeObject:taskID];\n         }\n+        [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n+        [currentExecutingTasks removeObject:taskID];\n+\n         /*\n          if(!isCollection){\n          \n@@ -120,11 +121,7 @@\n          NSDictionary* fileInfo = [localInfoDic valueForKey:onePath];\n          NSString* md5 = [fileInfo valueForKey:kGBFileAttributeMD5];\n          if(![[entry MD5Checksum] isEqualToString: md5]){\n-         \n-         [dataFacility insertEvent:entryChangestamp\n-         withEventCode:kGBServerFileUpdated\n-         operandA:entryIdentifier\n-         andOperandB:nil];\n+        \n          \n          }\n          }\n@@ -134,32 +131,9 @@\n         [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n         [currentExecutingTasks removeObject:taskID];\n     }else{\n-        //File not exist at local.\n+        //The entry not exist at local.\n         if(isCollection){\n-            NSLog(@\"Collection %@ added on server.\",entryTitle);\n-            \n-            NSString* path = operandB;\n-            NSString* identifier = operandA;\n-            NSManagedObject* mo = [dataFacility fetchCollectionByIdentifier:identifier];\n-            NSArray* pathEntries = [mo valueForKey:@\"localPaths\"];\n-            \n-            for(NSManagedObject* pathMO in pathEntries){\n-                NSString* pathString = [pathMO valueForKey:@\"stringValue\"];\n-                \n-                if([localInfoDic objectForKey:pathString]==nil){\n-                    //The local directory is not exist\n-                    //[GBUtility createLocalFolderAtPath:[pathMO valueForKey:@\"stringValue\"]];\n-                    [GBUtility createLocalFolderAtPath: pathString];\n-                    [GBUtility setIdentifier:identifier forFileAtPath:pathString];\n-                }\n-                //If the local directory is exist, then nothing have to be done.\n-            }\n-            \n-            [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n-            [currentExecutingTasks removeObject:taskID];\n-            \n-            //Server New Collection.\n-            \n+                        \n         }else{\n             //Server New File\n             NSLog(@\"Doc entry %@ added on server.\",entryTitle);\n@@ -176,12 +150,44 @@\n \n }\n \n+-(void)handleServerNewCollection:(NSManagedObject*)taskMO{\n+    NSManagedObjectID *taskID = [taskMO objectID];\n+    NSString* identifier = [taskMO valueForKey:@\"operandA\"];\n+    GDataEntryDocBase* entry = [docListData entryForIdentifier:identifier];\n+    NSString* entryTitle = [[entry title] stringValue];\n+\n+    NSLog(@\"Collection %@ added on server.\",entryTitle);\n+    \n+    NSArray* includingCollections = [collectionManager includingCollectionOfIdentifier:identifier];\n+    if(includingCollections!=nil&&[includingCollections count]==0){\n+        [GBUtility createLocalFolderAtPath: entryTitle];\n+        [GBUtility setIdentifier:identifier forFileAtPath:entryTitle];\n+    }else{\n+        for(GDataEntryFolderDoc* folder in includingCollections){\n+            NSString* folderIdentifier = [folder identifier];\n+            NSSet* parentPathSet = [localIdentifierDic valueForKey:folderIdentifier];\n+            for(NSString* parentPath in parentPathSet){\n+                //The local directory is not exist\n+                NSString* newPath = [NSString stringWithFormat:@\"%@/%@/\",parentPath,entryTitle];\n+                if([localInfoDic valueForKey:newPath]==nil){\n+                    [GBUtility createLocalFolderAtPath: newPath];\n+                    [GBUtility setIdentifier:identifier forFileAtPath:newPath];\n+                }\n+                //If the local directory is exist, then nothing have to be done.\n+            }\n+        }\n+    }\n+    [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n+    [currentExecutingTasks removeObject:taskID];\n+    \n+    //Server New Collection.\n+}\n+\n -(BOOL) handleTask:(NSManagedObject*) taskMO {    \n     NSManagedObjectID *taskID = [taskMO objectID];\n     [dataFacility setState:kGBStateExecuting ofTaskID:taskID];\n     NSInteger eventCode = [[taskMO valueForKey:@\"eventCode\"] intValue];\n     NSString *operandA = [taskMO valueForKey:@\"operandA\"];\n-    NSString *operandB = [taskMO valueForKey:@\"operandB\"];\n     switch(eventCode){\n \n         case kGBServerFileUpdated:{\n@@ -198,7 +204,6 @@\n             i=i+2;\n             break;\n         }\n-\n         case kGBLocalNewFile: {\n         \n             [NSTimer scheduledTimerWithTimeInterval:i\n@@ -242,7 +247,13 @@\n             [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n          break;\n         }\n-\n+            \n+        case kGBServerNewCollection:{\n+            //kGBServerNewCollection\n+            [self handleServerNewCollection:taskMO];\n+        }\n+            break;\n+            \n         case kGBServerDeleteFile:\n         case kGBServerDeleteCollection:{\n \n@@ -259,84 +270,19 @@\n         }\n             break;\n \n-        case kGBServerRename:{\n-            NSString* identifier = operandA;\n-            NSSet* pathSet = [localIdentifierDic valueForKey:identifier];\n-            NSString* suggestedName = [[docListData docListFeed]entryForIdentifier:identifier];\n-            NSError * error = nil;\n-            for(NSString* path in pathSet){\n-                NSString * newPath =[NSString stringWithFormat:@\"%@/%@\", [path stringByDeletingLastPathComponent],suggestedName];\n-                [[NSFileManager defaultManager] moveItemAtPath:[GBUtility expandedPath: path]\n-                                                        toPath:[GBUtility expandedPath: newPath]\n-                                                         error:&error];\n-            }\n-            \n-            [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n-            [currentExecutingTasks removeObject:taskID];\n-\n-        }\n-            break;\n-            \n         case kGBLocalDeleteFile:\n         case kGBLocalDeleteCollection:{\n             //kGBLocalDeleteCollection\n             NSString* path = [GBUtility simplifyLocalPath: operandA];\n-            NSManagedObject* pathMO = [dataFacility fetchLocalPathEntryByPathString:path];\n-            BOOL isFile = [[pathMO valueForKey:@\"isFile\"]boolValue];\n-            NSManagedObject* entryMO;\n-            if(isFile){\n-                entryMO = [pathMO valueForKey:@\"uniqueDocEntry\"];\n-            }else{\n-                entryMO = [pathMO valueForKey:@\"uniqueCollection\"];\n-            }\n-            NSString* identifier = [entryMO valueForKey:@\"identifier\"];\n-            \n-            [docListData deleteEntryByIdentifier:identifier];\n-            [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n-            [currentExecutingTasks removeObject:taskID];\n-            \n-\n             \n-        }\n-            break;\n-\n-        case kGBServerNewCollection:{\n-            //kGBServerNewCollection\n-            \n-            NSString* path = operandB;\n-            NSString* identifier = operandA;\n-            if(path ==nil){\n-                NSManagedObject* mo = [dataFacility fetchCollectionByIdentifier:identifier];\n-                NSArray* pathEntries = [mo valueForKey:@\"localPaths\"];\n-\n-                for(NSManagedObject* pathMO in pathEntries){\n-                    NSString* pathString = [pathMO valueForKey:@\"stringValue\"];\n-                    \n-                    if([localInfoDic objectForKey:pathString]==nil){\n-                        //The local directory is not exist\n-                        //[GBUtility createLocalFolderAtPath:[pathMO valueForKey:@\"stringValue\"]];\n-                        [GBUtility createLocalFolderAtPath: pathString];\n-                        [GBUtility setIdentifier:identifier forFileAtPath:pathString];\n-                    }\n-                    //If the local directory is exist, then nothing have to be done.\n-                }\n-                \n-            }else{\n-                \n-                [GBUtility createLocalFolderAtPath: path];\n-                [GBUtility setIdentifier:identifier forFileAtPath:path];\n-                \n-                    \n-            }\n+            NSString* identifier = [[localInfoDic valueForKey:path] valueForKey:kGBFileAttributeIdentifier];\n             \n+            [docListData deleteEntryByIdentifier:identifier];\n             [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n             [currentExecutingTasks removeObject:taskID];\n-\n-            \n             \n         }\n             break;\n-            \n         case kGBLocalNewCollection:{\n             //kGBLocalNewCollection\n             NSString* path = operandA;\n@@ -349,24 +295,6 @@\n         }\n             break;\n \n-        case kGBServerRemoveEntryFromCollection:{\n-            //kGBServerRemoveEntryFromCollection\n-            [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n-            [currentExecutingTasks removeObject:taskID];\n-\n-\n-        }\n-            break;\n-\n-        case kGBServerAddEntryToCollection:{\n-            //kGBServerAddEntryToCollection\n-            [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n-            [currentExecutingTasks removeObject:taskID];\n-\n-\n-        }\n-            break;\n-\n         case kGBLocalRename:{\n             //kGBLocalRename\n             NSString *path = [GBUtility simplifyLocalPath: operandA];\n@@ -383,30 +311,6 @@\n \n         }\n             break;\n-\n-            /*\n-        case kGBServerNoMD5FileExist:{\n-            //kGBServerNoMD5FileExist\n-            \n-            //Server side md5 is not avilable like user create the file at server side.\n-            \n-            //The file is donwloaded with extension of temp, this file will not be uploaded again, but it will be check against existing file, Then decide if a new file need to be created.\n-            \n-            //make sure the task handle logic is isolated from fetching process.\n-            NSManagedObject * docEntryEntity = [taskMO valueForKey:@\"relatedDocEntry\"];\n-            \n-            NSLog(@\"Downloading %@ \",[docEntryEntity valueForKey:@\"title\"]);\n-            [NSTimer scheduledTimerWithTimeInterval:i\n-                                             target:self\n-                                           selector:@selector(downloadTimerFireMethod:)\n-                                           userInfo:taskMOd\n-                                            repeats:NO];\n-            \n-            i=i+2;\n-            \n-        }\n-            break;\n-        */\n         case kGBLocalMoveEntry:{\n             [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n             [currentExecutingTasks removeObject:taskID];\n@@ -414,27 +318,6 @@\n             break;\n         }\n \n-        case  kGBFileExistPathsSubSet:{\n-            //kGBFileExistPathsSubSet \n-        \n-            NSString* existPath =operandB;\n-            NSString* identifier = operandA;\n-            NSManagedObject* mo = [dataFacility fetchDocEntryByIdentifier:identifier];\n-            for(NSManagedObject* moPath in [mo valueForKey:@\"localPaths\"]){\n-                if(![GBUtility isPathAtRoot:[moPath valueForKey:@\"stringValue\"]]){\n-                    [GBUtility cpFileAt:existPath\n-                                     to:[moPath valueForKey:@\"stringValue\"]];\n-                }\n-            }\n-            if([GBUtility isPathAtRoot:existPath]){\n-                [GBUtility removeFileAt:existPath];\n-            }\n-            [dataFacility setState:kGBStateDone ofTaskID:[taskMO objectID]];\n-            [currentExecutingTasks removeObject:taskID];\n-\n-        }\n-            break;\n-\n         default:\n             NSLog(@\"Unrecognized event code.\");\n     }\n@@ -459,6 +342,7 @@\n     NSString* path = [taskMO valueForKey:@\"operandA\"];\n     \n     NSString* identifier = [userInfo valueForKey:@\"kGBEntryIdentifier\"];\n+    \n     GDataEntryDocBase* uploadedEntry = [docListData entryForIdentifier:identifier];\n \n     if(eventCode == kGBLocalNewFile){\n@@ -466,7 +350,7 @@\n         [GBUtility setIdentifier:identifier forFileAtPath:[GBUtility simplifyLocalPath: path]];\n         \n     }else if(eventCode == kGBLocalFileUpdated){\n-        \n+        /*\n         NSManagedObject* pathMO = [dataFacility fetchLocalPathEntryByPathString:[GBUtility simplifyLocalPath: path]];\n         BOOL isFile = [[pathMO valueForKey:@\"isFile\"]boolValue];\n         NSManagedObject* entryMO;\n@@ -488,6 +372,7 @@\n             NSString* cPath = [pathMO valueForKey:@\"stringValue\"];\n             [GBUtility setIdentifier:identifier forFileAtPath:[GBUtility simplifyLocalPath: cPath]];\n         }\n+         */\n     }\n     [dataFacility setState:kGBStateDone ofTaskID:taskID];\n     [currentExecutingTasks removeObject:taskID];\n@@ -510,7 +395,7 @@\n     NSLog(@\"upload failed\");\n     NSManagedObjectID* taskID = [aNotification object];   \n     NSDictionary* userInfo = [aNotification userInfo];\n-    BOOL retryNeeded = [userInfo valueForKey:@\"retryNeeded\"];\n+    BOOL retryNeeded = [[userInfo valueForKey:@\"retryNeeded\"]boolValue];\n     if(retryNeeded){\n         [currentExecutingTasks removeObject:taskID];\n         [dataFacility setState:kGBStateWaiting ofTaskID:taskID];\n@@ -530,32 +415,32 @@\n     \n     NSManagedObjectID* taskID = [aNotification object];\n     NSManagedObject *taskMO = [dataFacility moForMOID:taskID];\n-    NSInteger eventCode = [[taskMO valueForKey:@\"eventCode\"] intValue];\n     //Server new file\n     NSString* identifier = [taskMO valueForKey:@\"operandA\"];\n     GDataEntryDocBase* entry = [docListData entryForIdentifier:identifier];\n-    NSManagedObject *mo = [dataFacility fetchDocEntryByIdentifier:identifier];\n-    \n-    NSString* pathAtRoot =[mo valueForKey:@\"title\"];\n+        \n+    NSString* pathAtRoot =[[entry title]stringValue];\n     \n     [GBUtility setIdentifier:identifier forFileAtPath:pathAtRoot];\n     \n-    if([[mo valueForKey:@\"parentCollections\"] count]!=0){\n-        \n-        for(NSManagedObject* moPath in [mo valueForKey:@\"localPaths\"]){\n-            if([moPath valueForKey:@\"stringValue\"]){\n-                \n-                [GBUtility createLocalFolderAtPath:[[moPath valueForKey:@\"stringValue\"] stringByDeletingLastPathComponent]];\n+    NSArray* includingCollections = [collectionManager includingCollectionOfIdentifier:identifier];\n+    if(includingCollections!=nil&&[includingCollections count]!=0){\n+        for(GDataEntryFolderDoc* folder in includingCollections){\n+            NSString* folderIdentifier = [folder identifier];\n+            NSSet* parentPathSet = [localIdentifierDic valueForKey:folderIdentifier];\n+            for(NSString* parentPath in parentPathSet){\n+                //The local directory is not exist\n+                NSString* newPath = [NSString stringWithFormat:@\"%@/%@\",parentPath,pathAtRoot];\n+                //[GBUtility createLocalFolderAtPath:[[moPath valueForKey:@\"stringValue\"] stringByDeletingLastPathComponent]];\n                 \n                 [GBUtility cpFileAt:pathAtRoot\n-                                 to:[moPath valueForKey:@\"stringValue\"]];\n+                                 to:newPath];                    \n                 \n+                //If the local directory is exist, then nothing have to be done.\n             }\n-            \n         }\n         [GBUtility removeFileAt:pathAtRoot];\n     }\n-        \n     [currentExecutingTasks removeObject:taskID];\n     [dataFacility setState:kGBStateDone ofTaskID:taskID];\n     ",
      "blob_url": "https://github.com/theplant/GBox/blob/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBTaskHandler.m"
    },
    {
      "raw_url": "https://github.com/theplant/GBox/raw/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBoxAppDelegate.m",
      "changes": 15,
      "status": "modified",
      "sha": "b13f907d49bf5b14f7182446ecebea9ac5b58c33",
      "additions": 7,
      "filename": "GBox/GBoxAppDelegate.m",
      "deletions": 8,
      "patch": "--- a/GBox/GBoxAppDelegate.m\n+++ b/GBox/GBoxAppDelegate.m\n@@ -140,10 +140,10 @@\n     //Initial Folder Creation\n     \n     \n-    /*\n+    \n     [defaults setBool:NO forKey:kGBSetupFinished];\n     [defaults synchronize];\n-     */\n+     \n     \n     // check if this is the first run.\n     setupFinished = YES;\n@@ -428,10 +428,10 @@\n     NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];\n     \n     NSData* pathData = [userDefaults objectForKey:@\"GBoxFolderPath\"];\n-    NSString *rootPath = [NSKeyedUnarchiver unarchiveObjectWithData:pathData];\n+    NSString *rootPath = [NSString stringWithString:[NSKeyedUnarchiver unarchiveObjectWithData:pathData] ];\n \n     if ([fm fileExistsAtPath:rootPath]) {\n-       newPath = [[rootPath stringByDeletingLastPathComponent] stringByAppendingPathComponent: @\"GBox_old/\"];\n+       newPath = [[rootPath stringByDeletingLastPathComponent] stringByAppendingPathComponent: @\"GBox_old\"];\n        //[fm moveItemAtPath:rootPath toPath:newPath error:nil]; \n         NSError* error = nil;\n         if(![fm fileExistsAtPath:newPath]){\n@@ -440,12 +440,12 @@\n                            attributes:nil\n                                 error:&error];\n         }\n-        \n+        NSArray* dirContents = [fm contentsOfDirectoryAtPath:rootPath error:&error];\n        [ [NSWorkspace sharedWorkspace] performFileOperation:NSWorkspaceMoveOperation\n                                                      source:rootPath \n                                                 destination:newPath \n-                                                      files:[fm contentsOfDirectoryAtPath:rootPath error:&error] \n-                                                        tag:nil]  ;  \n+                                                      files:dirContents\n+                                                        tag:0]  ;  \n         if(error!=nil){\n             NSLog(@\"error in backup: %@\",error);\n         }\n@@ -534,7 +534,6 @@\n     pathData = [defaults objectForKey:@\"GBoxFolderPath\"];\n     NSString *string = [NSKeyedUnarchiver unarchiveObjectWithData:pathData];\n     \n-    \n     //init GBox path string\n     NSString *pathString = @\"file://localhost\";\n     pathString = [pathString stringByAppendingString:string];",
      "blob_url": "https://github.com/theplant/GBox/blob/b13f907d49bf5b14f7182446ecebea9ac5b58c33/GBox/GBoxAppDelegate.m"
    }
  ],
  "stats": {
    "additions": 110,
    "deletions": 344,
    "total": 454
  },
  "committer": {
    "avatar_url": "https://secure.gravatar.com/avatar/38eb4e6b823b7e406e11de34be7fe61d?d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-140.png",
    "login": "chenxiaoyi",
    "id": 877966,
    "url": "https://api.github.com/users/chenxiaoyi"
  },
  "url": "https://api.github.com/repos/theplant/GBox/commits/b13f907d49bf5b14f7182446ecebea9ac5b58c33"
}
